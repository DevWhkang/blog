---
date: '2021-06-13'
title: 'Application, Operating System, System Resource의 관계 with Node.js'
categories: ['OS', 'JS', 'NODEJS']
summary: 'Node.js에서 javascript가 어떻게 운영체제, 하드웨어와 상호작용하는지 그 흐름을 정리한다.'
thumbnail: '../assets/async-sync-blocking-non-blocking/blocking.jpg'
---

# Overview

다양한 프로그래밍 언어가 있다. 특히 내가 관심을 두고 있는 Node.js는 Javascript를 브라우저뿐만 아니라 서버에서도 사용할 수 있게 해주는 런타임이다. 처음 접하는 사람은 런타임이라고 하는 용어가 어색할 수도 있겠다. Node.js는 하나의 실행 가능한 프로그램이고 런타임은 프로세스다. 이번 포스팅은 런타임에서 javascript가 어떻게 운영체제, 하드웨어와 상호작용하는지를 비동기 이벤트 처리 라이브러리인 libuv 중 'fs' 모듈을 예시로 정리하겠다.

Node.js를 처음 공부하는 사람들이 내가 어떤 위치에서 프로그래밍을 하고 있는지 알고 전체적인 컴퓨터 시스템 흐름을 알아가는데 도움이 되었으면 좋겠다.
잘못된 정보가 있다면 언제든지 댓글로 지적해주시기 바랍니다.

# Application, Operation System, System resource

먼저 "운영체제의 역할이 무엇이냐?"부터 간단히 말하자면, 운영체제는 어플리케이션, 프로그램이 실행될 때 메모리를 허가하고 분배한다. 이로써 프로세스 상태가 된다. 그리고 프로그램이 요청하는 CPU 자원을 점유할 수 있도록 시간을 제공하며, 여러 프로세스가 CPU 자원을 점유할 수 있도록 스케줄링 한다. 또한 I/O 디바이스 사용을 허가 및 제어한다. 운영체제는 우리가 컴퓨터를 사용할 때 가장 처음에 만나는 하나의 커다란 소프트웨어인 것이다.


![os-systemcall](/Users/devwhkang/Documents/blog/contents/assets/os-systemcall/os-systemcall.jpg)


## Shell

"컴퓨터 사용자가 어떻게 시스템 자원을 사용할 수 있는 것인가?"는 Shell이라는 인터페이스 때문이다. 프로그래밍을 해본 사람이라면 Shell이라는 용어가 익숙할 것이다. 익숙하지 않아도 좋다. Shell은 사용자가 운영체제에게 명령할 수 있는 통로와 같다고 생각할 수 있다. Shell은 우리가 바탕화면, 탐색기(Finder) 등 GUI 환경에서 파일을 저장하고, 삭제하고, 오픈하는 등의 행위들을 운영체제에게 전달하는 통로와 같다는 말이다. 즉, 우리는 Shell을 통해 운영체제에게 명령을 할 수 있는 것이다. 이와 같이 Shell은 GUI 형태로 제공되기도 하며, CUI 형태로도 제공된다. CUI 형태의 Shell은 bash 쉘, zsh 쉘 등이 있으며 터미널을 통해 사용할 수 있다. 또한 컴퓨터 사용자 뿐만 아니라 어플리케이션도 이 Shell을 통해 운영체제와 상호작용할 수 있다.

그렇다면 Shell은 어떻게 운영체제에게 어플리케이션과 사용자의 요청사항(명령)을 전달 할 수 있는 것일까?

## System call

시스템 콜은 운영체제가 어플리케이션에게 제공하는 API다. 즉, 운영체제라는 소프트웨어가 개발될 때 시스템 콜이라는 운영체제 사용법을 정의해 둔 것이다. Shell도 하나의 어플리케이션인데, Shell은 운영체제가 정의해놓은 시스템 콜을 이용하여 자신만의 명령어를 만든다. 예를 들어서 우리가 터미널에 `ls` 라는 명령(현재 디렉터리의 리스트를 출력하는 명령)을 치는 것이 Shell이 시스템 콜을 이용해서 만들어 놓은 명령어인 샘이다. 결국 시스템 콜을 이용하여 어플리케이션은 자신만의 명령어 혹은 API를 만들어낸다.

# Node.js가 시스템 리소스에 접근하기 까지

Node.js에만 한정해서 말하는 것은 아니다. C, C++, Java, python 등 다양한 프로그래밍 환경에서도 포함되는 얘기지만 Node.js를 예로 들겠다. Node.js는 어플리케이션이다. Node.js를 설치해본 사람을 알겠지만 `/usr/local` 과 같은(M1 전 mac OS 기준) 디렉터리에 실행 가능한 바이너리 형태로 설치해서 사용한다. 또한 편하게 사용하기 위해 우리는 Shell에게 Node.js 바이너리 경로를 알려주고 터미널에서 `node` 라는 명령어를 사용해 실행할 수 있게 된다.

## Node.js 비동기 이벤트 처리 라이브러리

Node.js는 기본적으로 단일 쓰레드 환경이다. 물론 멀티 쓰레딩이 가능한 모듈을 제공하기도 하지만 기본은 그렇다. 그리고 비동기 이벤트 처리 라이브러리 libuv를 가지고 있다. libuv 라이브러리에 포함되어 있는 모듈들은 멀티 쓰레드 환경에서 작업을 수행한다. 단일 쓰레드 환경에서 Javascript 코드를 실행하고 비동기 이벤트 처리가 필요하다면 libuv 라이브러리에서 필요한 모듈을 호출해 멀티 쓰레드 환경인 백그라운드로 넘긴다. 백그라운드에서 시스템 리소스에 접근하게 된다. 이때 시스템 콜을 사용하게 되는데, 비동기 모듈 'fs'를 예로 들어보겠다.

## 'fs' 모듈이 파일을 읽기 까지

'fs' 모듈은 결국 시스템 콜을 사용하기 위한 Node.js의 API인 셈이다. javascript라는 프로그래밍 언어로 시스템 리소스에 접근하기 위해 'fs'라는 API를 사용하게 되는 것이고 'fs' 모듈은 운영체제가 정의한 API인 시스템 콜 중 file system과 관련된 어떤 함수를 사용하고 있는 것이다. 이렇게 운영체제에게 요청(명령)을 할 수 있고 운영체제는 하드웨어에서 요청된 리소스 자원을 응답하거나 수행한다. 예를 들어 'fs' 모듈 중 파일을 읽는 메서드를 실행시켰다고 해보자. 백그라운드에서 해당 모듈은 시스템 콜의 파일 읽기와 관련된 함수를 실행시킨다. 운영체제는 스토리지에서 파일을 읽고 해당 내용을 이벤트로 시스템 콜을 호출하고 있는 메서드에게 보낸다. 이벤트를 받은 메서드는 자신을 호출한 곳으로 이벤트를 전달하기 위해 이벤트 루프 위에서 Task queue라는 공간으로 이동하고 Call Stack이 모두 비어 있다면 Call Stack에 Push되어 실행된다. 메서드를 호출한 Node.js 프로그램은 이를 콜백 함수로 받아 후 처리를 진행한다. 

이렇게 Node.js의 비동기 이벤트 처리 모듈은 동작하게 된다. 단편적으로 'fs' 모듈을 예시로 들었지만 라이브러리의 모든 모듈이 모두 같은 방식으로 동작하는 것은 아니다. 다만 "개념적으로 이렇다"라는 것을 정리했다. 운영체제가 어떻게 요청을 받을 수 있고 처리하게 되는지, 그러기 위한 인터페이스는 무엇인지를 간단하게 정리했다. 결국 high level programming language에서 어떻게 운영체제에게 명령을 내리는지에 대한 흐름이다.

